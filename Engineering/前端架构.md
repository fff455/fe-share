# 前端架构

## 前端架构总览

软件架构，贯穿软件的生命周期，一个完整的软件架构设计应该自上而下处理好：

- 系统间的关系，系统与其他系统是调用还是依赖关系
- 系统内的关系，如前端和后端，是以怎样的方式进行通信
- 应用内架构，包含应用相关的框架/组件
- 规范和原则，用于指导具体的代码编写

最初，前端是没有架构的，因为功能简单的代码没有架构可言。前端开发的发展历史可以分为如下几个阶段：

1. 古典时期，后端渲染出 HTML，前端用 CSS 进行简单的辅助
2. 动效时期，前端开始编写 JS，进行动画效果的制作
3. Ajax 通信时期，标志性事件是 2005 年 Google 在 Google Map 中首次使用异步通信的技术，开启了前端的新时代。一旦使用了异步通信，就意味着前端在运行时是需要动态渲染的。这时候，开发着需要做两件事：
   - 动态生成 HTML。后端返回 HTML，前端进行动态替换
   - 模板分离。后端 API 返回前端所需要的数据，前端通过模板引擎（Mustache 等）渲染 HTML
4. 借鉴后端的 MVC 架构，前端诞生了一系列早期的 MVC 框架，如 Backbone/Knockout 等
5. 在 Node.js 问世之后，前端的软件工程不断改善：
   - 构建工具：Gulp/Grunt 等
   - 包管理：NPM/Bower 等
   - 模块管理：Common.js/AMD 等
6. 随着单页应用的流行，前后端分离架构成为标准实践，前端考虑的内容越来越多：
   - API 管理：Swagger API 管理工具以及 Mock Server 成为标准实践
   - 大前端：前端实现跨平台跨端移动应用框架，如 Ionic，React Native，Flutter 等
   - 组件化：前端开始由组件构成，而非页面
7. 在 MVC 框架，React/Vue 等 MV\*的框架外，出现了微前端的概念，它解决了如下问题：
   - 跨框架，同一个页面可以运行多个框架
   - 拆分应用，复杂的应用拆分成细小的应用
   - 系统迁移，遗留的系统可以嵌入新系统运行

针对前端的系统分层，自上而下有以下层次的设计：

1. 系统级
   前后端分离架构设计，微前端架构设计
2. 应用级
   组件库，脚手架，设计库
3. 模块级
   组件化，模块化设计
4. 代码级
   规范，原则，质量

## 项目技术架构实施

项目的技术周期分为三个阶段：

1. 技术准备期  
   这个阶段，技术第一，业务第二。主要需要完成 3 个任务： - 架构设计 - 概念验证(PoC)：快速搭建与业务无关的示例代码，验证架构可行 - 迭代 0：搭建完整环境，更细粒度的技术选型，脚手架/代码库/CI/CD/权限
2. 业务回补期  
   业务开发过程正常，开始追回之前的业务累积，对应第一次业务的 DDL。这一阶段意味着技术上可能存在的调整有； - 测试策略调整，调低覆盖率，之后补回，加快开发速度 - 验证部署 - 提升团队能力：技术分享/WorkShop/结对编程/对外输出
3. 成长优化期  
   建立多次上线，业务开发流程相对固定，开始偿还技术债务：代码质量/测试覆盖率/依赖问题

## 工作流设计

工作流即我们开发过程中的流程和规范。具体的有如下几点：

1. 代码结构  
   代码结构是我们项目文件夹组织结构以及必要的文档介绍。对于前端项目来说，我们进入项目，能够： - 通过 README 阅读相关资料，一份好的 README 应该包含支持运行的环境/必要的依赖准备/如何搭建/安装指南/线上示例或线上地址/相关文档链接/相关人员，讨论群 - package.json 了解项目依赖/组件库/构建脚本 - 浏览配置目录（或文件）信息 - 阅读具体代码

2. 代码风格  
   前端项目中涉及代码风格的配置比较多，比较常用的有 Prettier/ESLint/CSSLint 以及编辑器的配置信息等。在多人协作的项目中，需要对这些规范进行强制性规范。这样的好处一来是能够统一项目代码风格，对新手阅读代码更加友好；二来是可以避免代码提交时来回产生不必要的 diff。

3. 架构图  
   对于架构复杂的系统而言，架构图必不可少

4. 代码提交规范

   - 版本管理工具（Git/SVN）统一
   - 提交信息需要规范
   - 为代码添加 pre-commit 检查：检查工作流是否存在不符合规范的行为

5. 测试策略
   对于 Web 应用的测试层级，自底向下有以下 4 层：

   - 单元测试
     选定单元测试框架，创建测试规则，指定测试覆盖率最小值
   - 组件测试
     功能测试，行为测试
   - 接口测试
     后端验证 API 是否与 Mock 数据统一，前端验证 Mock 数据或 API 是否满足前端需求
   - E2E 测试
     模仿用户行为，测试参数、参数类型、参数值、参数数量、返回值、抛出错误等，保证系统能够在任何情况下都稳定可靠完成工作

## 构建流设计

构建系统能够帮助开发者从系统的源代码构建出来可部署的软件。前端的构建系统需要处理如下问题：

1. 依赖管理工具  
   不同的模块化管理对应着不同的依赖管理工具； - AMD：Bower - CommonJS：NPM/Yarn
2. 包源管理  
   根据开发/组织的实际情况选择： - 公有/私有的包管理（NPM）源 - 源码版本管理器（Git）
3. 代码打包  
   在打包过程中，前端系统大部分的打包过程都交给相应的框架 CLI 进行打包
4. 构建流设计  
   设计构建流需要根据前端使用的框架/开发经验/框架脚手架功能进行设计，需要考虑的有如下几点：
   - 根据构建的复杂度选用不同的构建工具：Webpack（模块化打包）/Gulp/Grunt（复杂的项目工作流构建）或者直接使用 NPM（脚本简单的应用构建）
   - 步骤拆解：对于复杂的构建步骤（build），对其进行拆解，拆分出多个子命令
   - 自动化任务
5. CD  
   前端代码部署有 3 种方式：
   - 持续部署，构建完成即部署，常见于测试环境
   - 自动化部署，人为介入完成部署
   - 手动部署

## 多页应用设计

单页应用是指只有一个 Web 页面的应用，它能够动态改写当前页面的内容来达到和用户的交互。多页应用则指存在多个页面，当用户交互时，会请求新的页面进行展示。

首先，为什么会选择多页应用。单页应用是 Web 发展中的新产物，它在某些方面上做的并不好：

- 单页应用的学习成本高
- SEO 不友好
- 架构复杂，构建成本大

在多页应用的架构设计上，我们分为简单多页应用的设计和复杂多页应用的设计。

### 简单多页应用设计

由于单页应用的架构相对复杂，构建并执行一个单页应用的步骤很多，成本很大。所以，在实现一些轻量级应用时，使用多页应用可以快速并有效地进行开发。这类应用通常有：

- 门户，咨询，博客网站
- 弱交互应用，比如 Github 这种网站，不需要太多的交互
- 资源受限的设备应用，在嵌入式系统中，可能没有足够的 Web 资源使用单页应用

在简单多页应用的设计上，主要考虑以下几点：

1. 可能你并不需要框架

对于多数简单多页应用的设计上，你可能并不需要框架或者库来进行参与。以 JQuery 为例，原生的 JS 与 JQuery 相比并没有负责很多，JQuery 简化了 HTML 和 JS 的操作，但使用原生 JS 的写法也能够满足需要，只不过原生 JS 的写法会更长一些。可以通过封装常用函数，甚至简单封装到一个新的命名空间下进行快捷使用，就像 JQuery 中的`$()`一样

2. 选择 UI 库

选择一个 UI 库进行开发，很多团队会选择自己进行封装 UI 库，或者直接从外部引入优秀的 UI 库，比如 Bootstrap

3. 选择框架

常用的比如 JQuery/Zepto

### 负责多页应用设计

实际情况下，应用并不是总是那么理想。使用多页应用过于简单，使用单页应用过于复杂。多页应用和单页应用之间存在着一些交集，而这些交集也影响着我们如果进行单页还是多页的选择。

这里我们主要对交集中的三个方面进行解释：

1. 模板引擎

   对于一些相对固定的业务模块，比如弹窗，我们可以采用模板来动态生成。最简单的方式是拼接 HTML 字符串。对于一些简单的处理，确实是可以使用字符串拼接的方式，但是如果要生成比较复杂的 HTML，需要使用模板引擎。模板引擎分为两类，一类是基于字符串的模板引擎，一类是基于 JS 的模板引擎。

   - 基于字符串模板引擎

   基于字符串的模块引擎是通过字符串替换的方式来渲染 HTML，再将 HTML 插入到 DOM 中。代表框架有 Mustache/HandlerBars.js/Jeklly/Hexo/Assemble。
   这种处理方式的原理是全局正则匹配关键词，例如`{% name %}`，再从传入的参数中找到 name 的值然后进行替换。这种引擎在更新 DOM 时会更新所有 DOM 节点，然后浏览器再重新渲染所有节点，这对于有大量节点或者大量操作的情况来说是不合适的。

   - 基于 JS 的模板引擎

   基于 JS 的模板引擎需要先将模板转义成 JS，然后在执行时动态修改 DOM，主要步骤如下：

   1. 将模板编译成某种 DSL(HypeScript/JavaScript)
   2. 使用时，调用 JS 来更新 DOM 节点
   3. 当发生变化时，通过 DOM diff 算法来更新 DOM

   它与基于模板的引擎最大的区别就是第三点，是否进行全局替换还是对变化的 DOM 进行局部替换。

2. 双向绑定

   双向绑定即双向数据绑定，视图(View)的变化能改变数据模型(Model)的数据，同时，数据模型的变化也行实时反映在视图的变化上。

   对于双向绑定，有以下几种实现方式：

   - 手动绑定，当一方数据进行改变时，去手动修改数据或者改变 UI
   - 脏检查，当发生事件时(HTTP/DOM)，只去检查事件对应的数据和 DOM，然后对发生变化的数据/DOM 进行修改
   - 数据劫持，通过 hack(Object.defineProperty)的方式对数据的 setter 和 getter 进行劫持，当数据变化时，通知相关的订阅者，以触发相应的事件回调

3. 前端路由

   传统的多页面应用，路由是由后端控制的，当发生变化时，也由后端进行处理。而单页面应用的路由则完全由前端控制，用于连接分散到各处的控制逻辑。

   前端路由主要有两种实现方式：

   - 基于 History  
      HTML5 的 History API 可以实现无刷新更改地址栏链接，它提供的方法可以满足单页应用所有的需求(back/forward/go/pushState/replaceState)，通过 JS 可以操作这些 API。
   - 基于 Hash  
      基于 Hash 的路由是通过 Url`#`后面的内容进行修改。DOM API 的 location.hash 可以获取当前页面的 hash，当页面的 hash 改变时，我们可以通过监听 window 的`hashChange`事件，来找到对应绑定的模块。Hash 路由有以下特点：
     - hash 改变不会导致页面重新加载
     - hash 有浏览器控制，不会发送到服务器
     - hash 的变化会记录在浏览器历史里，因此可以进行前进和后退

## 单页应用设计

在业务不断发展的过程中，前端应用也变得不断复杂，前端的各个页面也趋向组成一个独立的应用，而不是使用依赖后端渲染的多页应用。在开发一个单页应用的过程中，有几个点是我们密切关注的：
1. 前端应用的MV*框架
2. 前端三大框架如何选择
3. 开发好单页应用应该使用哪些技术
4. 单页应用的后台渲染

### 前端应用的MV*框架

架构是在不断的实践中总结出来的，在实践的过程中，工程师不断对软件进行抽象化。其中，MVC框架是这个过程中整理出来的一个好的框架。

MVC框架在前端的体现是

- Model 获取/存放所有对象数据
- View 呈现信息给用户
- Controller Model与View之间的纽带

我们可以使用原生JS实现MVC的代码结构，但是在各处实行MVC框架操作上会变得非常繁琐，而且代码也难以维护。因此，我们需要前端框架来帮我们解决：

- UI与Model的同步问题
- 如何将代码变得易于维护

### 前端三大框架如何选择

前端目前流行的三大框架是React/Vue/Angular，各个框架之间既有类似的设计，也有各自不同的优势。在实际应用中，不同的团队选择的框架也是不同的，在选择框架时有几点我们需要考虑：

- 框架能否满足大部分的应用需求
- 团队对框架的掌握情况如何
- 框架是否有丰富的组件库
- 框架的社区环境如何，遇到问题能否找到解答
- 框架的替换成本/现有项目的迁移成本
- 框架的维护成本/难度

#### React

React是一个为数据提供渲染成HTML的JS框架。从定义来看，React是一个View层框架，提供了数据渲染的机制。

React是第一个使用Virtual DOM的前端流行框架。除了Virtual DOM，React的一个重要思想是组件化，即UI每个组件都应该是独立封装的。React引进了JSX语法，可以在JS中编写模板。

React是一个View层的框架，它是为了优化DOM操作而诞生。但是对于前端应用来说，还需要一系列Controller以及Model的管理（路由/单向数据流库等）。依赖于React优秀的社区环境，这些库都可以在React社区中找到比较主流的解决办法。

选择React还有一个特点是React的设计思想不止局限在前端领域中，React Native/React VR/Electron可以在不同的平台上运行React应用，因此React的处理逻辑可以得以复用。

#### Angular

Angular是一个大而全的框架，它提供了一个前端应用完整的要素。Angular提供了开发应用所需的脚手架，测试，运行，打包等部分。除此之外，Angular默认还提供了动画/HTTP/表单/路由/单元测试/E2E测试以及静态分析等内容。

Angular除了提供开发前端应用的所有要素外，还提供了开发规范。这些严格的规范更加适合大公司的运作，尤其金融/保险类的公司。

Angular虽然没有官方的Web领域之外的平台方案，但是社区拥有一些框架，例如NativeScript/Ionic等框架，它们都可以在某种程度上与Web平台逻辑共用。

#### Vue

Vue借鉴了Angular和React的一些思想，在其基础上开发了一套更加易于上手的框架。学习Vue需要学习Vue的Template语法。

Vue针对React和Angular的一个优势是Vue针对传统的多页应用直接引入vue.min.js就可以直接使用，在代码库上直接发布就可以，不需要打包。针对从多页应用迁移前端框架的项目来说提供了渐进式的迁移方案。

Vue还拥有使用类似语法的Weex框架，熟悉了Vue可以快速上手Weex这样类似RN的跨端框架。但是受限与Weex的发展，Weex在移动应用上的发展并不理想。

### 开发好单页应用应该使用哪些技术

选好前端框架后，之后的步骤有：

1. 寻找合适的脚手架，脚手架的任务主要有：通用的业务相关模块/页面模板/业务模板/CI，CD脚本/常用的依赖
2. 寻找合适的UI框架（是否跨框架，是否易于替换）
3. 明确浏览器的支持程度，明确测试边界
4. 明确响应式的需求，明确支持的设备

### 单页应用的后台渲染

对单页应用使用服务端渲染主要有两个好处：
- SEO
- 更快的内容到达

单页应用的服务端渲染主要有三种类型：

- 非JS的同构渲染

   同构渲染，指前后端共享模板文件，非JS是指与目前流行的Node.js同构渲染的区别。这时，需要寻找后端支持的模板类型，然后找到一个合适的模板引擎。在用户或者爬虫访问URL时，会由后端获取数据对应的模板文件，然后渲染出HTML给用户或者爬虫。使用这种技术相当于将一个单页应用变成了多页应用。

   当用户或者爬虫直接访问URL时，由后端渲染HTML。当用户从当前页面跳转到其他页面时，由前端渲染，不经过后端。当用户刷新时，重新由后端返回HTML。

- 基于JS的同构渲染

   对于前端开发人员来说，使用Nodejs来进行同构渲染更容易上手。由于是同一门语言，对于很多API和语法来说都不用进行修改，只需要将前端页面的状态传递过来即可。使用同构渲染还有一个好处是主流框架都提供了`renderToString`(React/Vuew)或`renderModuleFactory`(Angular)的支持。它们的主要逻辑相似，都是通过在这个方法中传入引用的组件，就可以直接输出HTML，再借助后端框架进行HTML的输出。

   使用同构渲染也会带来一些问题：
   1. 后端有内存溢出的危险
   2. 前端组件和模块需要兼容浏览器和Node环境
   3. 提供状态的获取和同步机制

## 组件化设计

从前端的视角来看，大到一整个页面，小到一个小UI部件，都可以称作为组件。基于组件的架构设计侧重于将广泛使用的功能模块独立出来，将独立的功能分离出来，降低系统的耦合度。从小组件到整个页面的顺序来看，组件化设计主要包含：风格设计/UI组件库/设计系统

### 风格设计

1. 原则

在风格设计上，主要遵循以下原则：

   - 亲密性：相关的组件组织到一起
   - 对齐：每一项都应该与页面的其他相关内容建立某些视觉联系
   - 重复：重复的元素表现应该一致
   - 对比强烈：对比产生强调

2. 色彩

在Web应用中，需要一系列的色彩来建立用户友好的页面，这些色彩通常会做如下分类：

   - 主题色
   - 功能色：展示数据和状态
   - 中性色：页面的过渡和常规显示

3. 文字

在早期的Windows系统中，是没有奇数字体大小的，多数的字体都是偶数的，这个习惯一直延续至今。通常，设计人员会在大于14px的偶数字体大小中进行选择。

对于字体来说，不同系统之间最常使用的字体也不同，macOS最常使用`PingFang SC`，Windows最常使用`Microsoft YaHei`，而Linux最常使用`WenQuanYi Micro Hei`。因此，全局CSS可以这么设置：

```css
body {
   font-family: -apple-system, BlinkMaxSystemFont, Helvetica Neue, PingFang SC, Microsoft YaHei, Source Han Sans SC, Noto Hans CJK SC, WenQuanYi Micro Hei, sans-serif;
}
```

4. 布局

目前，最常用的前端布局主要有栅格布局和Flex布局。

### 组件库

组件库有一系列优点：

- 提升开发效率，无需重复编写代码
- 一致化，避免了代码重写带来的样式/功能的不统一
- 提高可维护性

根据复杂程度和业务相关性可以分为三类组件：

1. 基础UI组件

通常由项目的UI组件库提供，提供页面最小粒度的组件，例如button/select。

2. 复合组件

复合组件通常由基础UI组件构成，它们互相之间进行某些连接，有相互的联动效果，可以在基础组件的基础上封装出复合组件。

3. 业务组件

业务组件是实现业务功能时抽出的组件，它们通常设计到更复杂的业务场景，很多时候不止本项目可用，也可提供给其他系统和项目进行使用。通常，在业务组件下，又可以分为应用相关组件和领域特定组件。

应用相关组件是与应用逻辑绑定在一起的组件，通常不会在其他系统中进行使用，如：前端密码校验规则/对后端错误规则的响应/对后端响应的处理/登录后的处理逻辑。

领域特定组件是可以用于特定行业的组件，例如腾讯广点通的广告选择表单。

### 设计系统

设计系统是一组相互关联的设计模式与共同实践的结合。设计系统包含了完整的设计标准/文档/原则和工具包。设计系统是一个开发人员和设计人员写协作的产物。

构建设计系统时，需要用到模块的分层方法，并且能与组件库进行结合。从微观到宏观有以下五个不同阶段：

- 原子，基本的HTML标签
- 分子，由基本标签组成的简单组织，例如导航栏
- 有机体，原子/分子组织而成的相对复杂的UI组织，例如header和footer
- 模板，构建整体布局，将组件与上下文结合起来，例如博客的一个页面是由header+footer+博客内容组建而成
- 页面，真实的数据展示出来的最终产品，可用于测试系统弹性

## 前后端分离架构设计

## 微前端架构设计

## 演进式架构
